//http://www.gradle.org/docs/current/userguide/userguide.html

ext {
  fullName = 'rulex'
  fullDescription = 'Rulex - Rule Production System Framework'
  teamName = 'Rulex Team'
  maintainerName = 'Vadim Bondarev/haghard84@gmail.com'
  siteUrl = 'http://xxxx.github.com/Some Framework'
  sourceUrl = 'git://github.com/haghard/Rulex.git'
  githubProjectName = project.name
  javaCompilerExecutable = System.env['JAVA_HOME'] ? System.env['JAVA_HOME'] + '/bin/javac' : 'javac'
}

defaultTasks 'build'

buildscript {
  repositories {
    mavenLocal()
    jcenter()
  }
  dependencies { classpath 'com.mapvine:gradle-cobertura-plugin:1.0' }
}

apply plugin: 'java'
apply plugin: 'cobertura'
apply plugin: 'application'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'maven'

apply from: 'gradle-plugins/RulexGradlePlugin.gradle'
apply from: 'gradle-plugins/checks.gradle'

group = 'ru.rulex.conclusion'
version = '0.1'
description = 'Rule Production System'


//-source <release>          Provide source compatibility with specified release
//-target <release>          Generate class files for specific VM version
sourceCompatibility = JavaVersion.VERSION_1_6
targetCompatibility = JavaVersion.VERSION_1_6

tasks.withType(Compile)
{
  options.compilerArgs << '-XDignore.symbol.file' << '-Xlint:unchecked'
  options.debug = true
  options.fork = true
  options.warnings = false
  options.forkOptions.executable = javaCompilerExecutable

  def compilerArgs = "gradle task ${name} : Args :"
  options.getCompilerArgs().each { compilerArgs += "${it}\t" }

  println "Compile args: ${compilerArgs}"
}

//print Jvm args for specified testTask
gradle.taskGraph.beforeTask { Task task ->
  def testTaskList = [ 'test', 'testGuiceApi', 'testGroovyApi', 'testDaggerApi']
  if (testTaskList.isCase(task.name)) {
    def jvmArgsLine = "JVM arg for $task  : "
    task.allJvmArgs.each { jvmArgsLine += "${it}\t" }
    println "${jvmArgsLine}"
  }
}

task printProjectProperties(description: 'This task print all project properties') {
  doFirst {
    println "---Project all properties Size: ${project.getProperties().size()}----"
    def store = ''
    def count = 0
    project.getProperties().each {
      store += "${count}: ${it.key} : ${it.value}\n"
      count++
    }
    println  store
    println "--------------------Project all properties---------------------------"
  }
}

task sourceSetJavaProperties(description: 'This task do print project setting') {
  sourceSets {
    main {
      doFirst {
        println "java.srcDirs = ${java.srcDirs}"
        println "resources.srcDirs = ${resources.srcDirs}"
        println "java.files = ${java.files.name}"
        println "allJava.files = ${allJava.files.name}"
        println "resources.files = ${resources.files.name}"
        println "allSource.files = ${allSource.files.name}"
        println "output.classesDir = ${output.classesDir}"
        println "output.resourcesDir = ${output.resourcesDir}"
        println "output.files = ${output.files}"
      }
    }

    test {
      doLast {
        println "output.resourcesDir = ${output.resourcesDir}"
        println "output.files = ${output.files}"

        println "testReportDir = ${testReportDir}"
        println "testResultsDir = ${testResultsDir}"
      }
    }
  }
}

task printJVMSourceTargetSetting {
  doFirst {
    println "--------------JVM setting----------------------- "
    println "targetCompatibility ${project.targetCompatibility}"
    println "sourceCompatibility ${project.sourceCompatibility}"
  }
}

task printProjectSettings(dependsOn: printJVMSourceTargetSetting) {
  doFirst {
    println "---------------Project settings------------------- "
    println "buildDir ${project.buildDir}"
  }
  doLast {
    println "buildFile ${project.buildFile}"
    println "version ${project.version}"
  }
}

gradle.taskGraph.whenReady { taskGraph ->
  if (taskGraph.hasTask(printProjectSettings)) {
    //println "Find executable task Yeeeep!!!"
  } else {
    //println "Find executable task Nooop!!!"
  }
  println 'Execution gradle task graph :'
  gradle.taskGraph.getAllTasks().each { println "Graph gradle task: ${it}" }
}


repositories {
  jcenter()
  // required to get ReportNG 1.1.3 (central Maven repo has only 1.1.2)
  mavenRepo url: 'http://clojars.org/repo'
  //this is how to add ext repo url
  //mavenRepo url: 'http://people.apache.org/repo/m2-incubating-repository'
  //mavenRepo url: 'http://maven.davidtrott.com/repository'
}

//http://blog.codeaholics.org/2012/emulating-mavens-provided-scope-in-gradle/
configurations {
    provided
}

dependencies {
  compile 'log4j:log4j:[1.2,)'
  compile group: 'com.google.guava', name: 'guava', version: '15.0'

  compile 'cglib:cglib-nodep:2.2.2'
  compile 'org.hamcrest:hamcrest-all:1.3'
  compile 'org.codehaus.groovy:groovy-all:2.1.7'

  compile 'com.google.inject:guice:3.0'
  compile 'com.google.inject.extensions:guice-multibindings:3.0'
  compile 'com.google.inject.extensions:guice-assistedinject:3.0'

  compile 'com.squareup.dagger:dagger:1.1.0'
  provided 'com.squareup.dagger:dagger-compiler:1.1.0'

  testCompile group: 'org.testng', name: 'testng', version: '6.8'
  // Add at least version 4.8 of JUnit as dependency.
  testCompile 'junit:junit:[4.8,)'
  testCompile group: 'org.uncommons', name: 'reportng', version: '1.1.3'
  testCompile group: 'org.mockito', name: 'mockito-all', version: '1.9.0'
  testCompile group: 'org.easytesting', name: 'fest-assert-core', version: '2.0M8'
  // workaround for a known issue with TestNG 6.x: explicitly add Guice (Gradle will fail to run tests otherwise)
  testCompile group: 'com.google.inject', name: 'guice', version: '3.0'
  testCompile 'org.apache.onami:org.apache.onami.test:1.4.0-incubating'

}

// ensure that test resources (src/test/resources) are added to CLASSPATH;
// see http://forums.gradle.org/gradle/topics/tests_arent_executed_when_setting_the_test_runtimeclasspath and
// http://gradle.org/docs/current/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:classpath
sourceSets {
  main {
    runtimeClasspath = files(output.resourcesDir) + runtimeClasspath
    compileClasspath += configurations.provided
  }
  test {
    runtimeClasspath = files(output.resourcesDir) + runtimeClasspath
    compileClasspath += configurations.provided
    runtimeClasspath += configurations.provided
  }

  perf {
	  java {
		  srcDir 'src/perf/test'
	  }
  }
}

//sourceSets { perf.java.srcDir 'src/perf/test' }

eclipse.classpath.plusConfigurations += sourceSets.perf.compileClasspath

compilePerfJava { classpath += sourceSets.main.runtimeClasspath }

test {
  //try to set JAVA_HOME for tests
  environment << ['JAVA_HOME' : javaCompilerExecutable]
  //The maximum number of test classes to execute in a forked test process.
  //The forked test process will be restarted when this limit is reached. The default value is 0 (no maximum).
  forkEvery = 50

  //The maximum number of forked test processes to execute in parallel. The default value is 1 (no parallel test execution)
  //maxParallelForks 4

  //enable JUnit support (default is JUnit)
  useJUnit()

  //ignoreFailures = true
  // explicitly include or exclude tests

  include '**/Test*'

  // show standard out and standard error of the test JVM(s) on the console
  //testLogging.showStandardStreams = true

  // set heap size for the test JVM(s)
  minHeapSize = "226m"
  maxHeapSize = "512m"

  // set JVM arguments for the test JVM(s)
  //option '-XX:UseSplitVerifier' is a workaround for issue JDK7 + cobertura
  jvmArgs "-XX:-UseSplitVerifier", "-XX:MaxPermSize=256m"

  // listen to events in the test execution lifecycle
  beforeTest { descriptor -> logger.lifecycle("Running test: " + descriptor) }

  // listen to standard out and standard error of the test JVM(s)
  onOutput { descriptor, event -> logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message ) }
}

task testGuiceApi(type: Test) {
  useJUnit()
  //ignoreFailures = true
  include '**/Guice*'
  maxHeapSize = "512m"
  jvmArgs "-XX:-UseSplitVerifier", "-XX:MaxPermSize=256m"
  beforeTest { descriptor -> logger.lifecycle("Running test: " + descriptor) }
  onOutput { descriptor, event -> logger.lifecycle("Test: " + descriptor + " out/err: " + event.message ) }
}

task testGroovyApi(type: Test) {
  useJUnit()
  //ignoreFailures = true
  include '**/Groovy*'
  maxHeapSize = "512m"
  jvmArgs "-XX:-UseSplitVerifier", "-XX:MaxPermSize=256m"
  beforeTest { descriptor -> logger.lifecycle("Running test: " + descriptor) }
  onOutput { descriptor, event -> logger.lifecycle("Test: " + descriptor + " out/err: " + event.message ) }
}

task testDaggerApi(type: Test) {
    useJUnit()
    //ignoreFailures = true
    include '**/Dagger*'
    maxHeapSize = "512m"
    jvmArgs "-XX:-UseSplitVerifier", "-XX:MaxPermSize=256m"
    beforeTest { descriptor -> logger.lifecycle("Running test: " + descriptor) }
    onOutput { descriptor, event -> logger.lifecycle("Test: " + descriptor + " out/err: " + event.message ) }
}

// usage: gradle clean testTestSet -PtestSet=**/Test*
task testTestSet(type: Test) {
  doFirst {
    useJUnit()
    if (project.hasProperty('testSet')) {
      println "Run test with pattern ${testSet}"
      //ignoreFailures = true
      include testSet
      beforeTest { descriptor -> logger.lifecycle("Running test: " + descriptor) }
      onOutput { descriptor, event -> logger.lifecycle("Test: " + descriptor + " out/err: " + event.message ) }
    } else {
      println 'Property testSet not found'
    }
  }
}
//
/*
task aggregateTestReports(type: TestReport) {
    destinationDir = test.reports.html.destination
    reportOn test, testNG
}
check.dependsOn aggregateTestReports
*/

test.dependsOn testDaggerApi
test.dependsOn testGuiceApi
test.dependsOn testGroovyApi


tasks.addRule("Pattern: <TaskName>-desc: Show description of a task.") { taskName ->
  if (taskName.endsWith('-desc')) {
    println "Dinamicaly add desc task to ${taskName}"
    def targetTaskName = taskName - '-desc'
    def targetTaskNameUncapitalize = targetTaskName[0].toLowerCase() + targetTaskName[1..-1]
    def targetTask = project.tasks.findByName(targetTaskNameUncapitalize)
    if (targetTask) {
      //dynamiclly run new task
      task(taskName)  { println "Description of task ${targetTask.name} -> ${targetTask.description}" }
    } else {
      println "can't find task ${targetTaskNameUncapitalize}"
    }
  }
}

jar {
  manifest.attributes('Built-By': System.properties['user.name'],
  'Bundle-Name': fullName,
  'Bundle-Vendor': teamName,
  'Bundle-Description': fullDescription,
  'Bundle-DocURL': siteUrl)
}

task sourcesJar(type: Jar) {
  classifier = 'sources'
  from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

artifacts { archives sourcesJar, javadocJar }

// see https://github.com/Mapvine/gradle-cobertura-plugin
cobertura {
  format = 'xml'
  includes = ['**/*.java']
  excludes = []
}

task writeNewPom {
  pom {
    project {
      scm {
        url = "scm:$sourceUrl"
        connection = "scm:$sourceUrl"
      }

      inceptionYear '2013'
      licenses {
        license {
          name 'The Apache Software License, Version 2.0'
          url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        }
      }

      developers {
        developer {
          id = 'team'
          name = teamName
          email = 'haghard84@gmail.com'
        }
      }
    }
  }.writeTo("pom.xml")
}

uploadArchives {
  repositories {
    mavenDeployer { repository(url: localRepo) }
  }
}

writeNewPom.dependsOn build
uploadArchives.dependsOn build
install.dependsOn build

mainClassName = "someClass"


task wrapper(type: Wrapper) {
    gradleVersion = '1.8'
}